# 详细设计


## spec配置定义
```json
{
  "name": "example",
  "version": "v1",
  "dag": [
    {
      "id": "5c42b900-a87f-45e3-ba06-c40d94ad5ba2",
      "name": "ComputeUnit1",
      "dependency": [
        
      ],
      "spec": {
        "cmd": [
          "ls"
        ],
        "image": ""
      },
      "channel": {
        "spec": {
          "cmd": [
            "bufsize",
            "1024"
          ],
          "image": "jiaozifs:"
        }
      }
    },
    {
      "id": "353fc5bf-697e-4221-8487-6ab91915e2a1",
      "name": "ComputeUnit2",
      "node_type": "ComputeUnit",
      "dependency": [
        "5c42b900-a87f-45e3-ba06-c40d94ad5ba2"
      ],
      "spec": {
        "cmd": [
          "ls"
        ],
        "image": ""
      }
    }
  ]
}
```

## Graph

1. 节点= 节点+数据管道(可选)

## job 控制器

追踪整个job的运行状态，处理重试，日志，状态收集的问题的问题

## Pipe流控制器

负责pipeline的部署，及状态监控

## 节点控制

控制节点和数据管道的部署，操纵及状态监控
* deploy
* status
* monitor

# 节点接口设计

## 节点程序接口设计

* init
* start
* restart
* pause
* stop
* subscribe

## 数据通道程序接口设计

* init
* start
* restart
* pause
* stop
* subscribe

## 节点是被动接受数据还是主动拉取数据

被动接受: 实时性好，容易保证下游下游节点都获取到数据，不利于实现容量控制。
主动拉取: 容易实现流量控制， 实时性差，不容易保证所有下游节点都获取到数据。

## 持久化缓存和内存缓存

持久化缓存可用性更好，内存缓存性能更优

## 可用性与性能难以兼得

可用性更高意味着更多的可靠性保障，更多的持久化操作。而在一个分布式系统中，这意味着更多的磁盘写入，更多的网络请求与确认。